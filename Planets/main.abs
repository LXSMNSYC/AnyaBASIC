start
	Pi = 3.141592653589793

	function getRadius(area)
	start
		return sqrt(area/Pi)
	end
	
	var zoomFactor = 1.0
	var zoomInc = 0.1
	function zoomIn()
	start
		zoomFactor = zoomFactor*(1 + zoomInc)
	end

	function zoomOut()
	start
		zoomFactor = zoomFactor - zoomInc
	end
	
	function map2screenX(msx, msxoffset)
	start
		return (msx - msxoffset)*zoomFactor
	end

	function map2screenY(msy, msyoffset)
	start
		return (msy - msyoffset)*zoomFactor
	end

	function screen2mapX(smx, smxoffset)
	start
		return (smx/zoomFactor) + smxoffset
	end

	function screen2mapY(smy, smyoffset)
	start
		return (smy/zoomFactor) + smyoffset
	end
	
	type Rect
	start
		minx = 0
		maxx = 0
		miny = 0
		maxy = 0
		cenx = 0
		ceny = 0
	end

	function createRect(rminx, rminy, rmaxx, rmaxy)
	start
		Rect r
		r.minx = rminx
		r.miny = rminy
		r.maxx = rmaxx
		r.maxy = rmaxy
		r.cenx = (rmaxx + rminx)/2
		r.ceny = (rmaxy + rminy)/2
		return r
	end

	function rectContainsX(rcx, rtx)
	start
		return rcx.minx < rtx && rcx.maxx > rtx
	end

	function rectContainsY(rcy, rty))
	start
		return rcy.miny < rty && rcy.maxy > rty
	end

	function rectContainsXY(rcp, rtpx, rtpy)
	start
		return rectContainsX(rcp, rtpx) && rectContainsY(rcp, rtpy)
	end

	function rectboundX(rbx, rbtx)
	start
	if(rbx.minx > rbtx) then return rbx.minx
		else if (rbx.maxx < rbtx) then return rbx.maxx
		else return rbtx
	end

	function rectboundY(rby, rbty)
	start
		if(rby.miny > rbty) then return rby.miny
		else if (rby.maxy < rbty) then return rby.maxy
		else return rbty
	end
	
	Rect map
	map.maxx = 2048
	map.maxy = 2048
	
	function getRandomX()
	start
		return random(map.maxx)
	end 
	
	function getRandomY()
	start
		return random(map.maxy)
	end 
	
	Rect camera 
	
	function moveCamera(mcx, mcy)
	start
		var width = (camera.maxx - camera.minx)/2
		var height = (camera.maxy - camera.miny)/2
		camera.cenx = mcx
		camera.ceny = mcy 
		camera.minx = mcx - width
		camera.maxx = mcx + width
		camera.miny = mcy - height 
		camera.maxy = mcy - height
	end 
	
	function isVisible(ivx, ivy)
	start
		return rectContainsXY(camera, ivx, ivy)
	end
	
	type Chunk
	start
		radius = 8
		mass = 201.061929829746767
		
		x = 0
		y = 0
		
		r = 0
		g = 0
		b = 0
	end
	var chunkdelay = 1.0
	var chunktimer = 0
	
	var chunkrate = 4
	
	Chunk chunks[8192]
	var chunkc = 0
	
	function createChunk()
	start
		chunks[chunkc].x = getRandomX()
		chunks[chunkc].y = getRandomY()
		chunks[chunkc].r = random()
		chunks[chunkc].g = random()
		chunks[chunkc].b = random()
		chunkc = chunkc + 1
	end
	
	function updateChunk(ucfps)
	start
		if(chunktimer < chunkdelay)then chunktimer = chunktimer + ucfps
		else
		start
			chunktimer = 0
			for(var i = 1 to chunkrate step 1)
			start
				createChunk()
			end
		end
	end
	
	function drawChunks()
	start
		for(var i = 0 to chunkc step 1)
		start
			Chunk dc
			dc = chunks[i]
			if(isVisible(dc.x, dc.y)) then
			start
				setColor(dc.r, dc.g, dc.b, 0.392156862745098)
				drawEllipse(dc.x, dc.y, dc.radius, dc.radius, 0)
				setColor(dc.r, dc.g, dc.b, 1)
				drawEllipse(dc.x, dc.y, dc.radius, dc.radius, 0)+
			end
		end
	end
	
	function destroyChunk(dcchunk)
	start
		if(dcchunk <= chunkc) then
			chunks[dcchunk].x = chunks[chunkc].x
			chunks[dcchunk].y = chunks[chunkc].y
			chunks[dcchunk].r = chunks[chunkc].r
			chunks[dcchunk].g = chunks[chunkc].g
			chunks[dcchunk].b = chunks[chunkc].b
			chunkc = chunkc - 1
		end
	end
	
	function getNearestChunk(gncx, gncy)
	start
		Chunk near
		var dist = 2147483648
		for(var i = 0 to chunkc step 1)
		start
			var len = sqrt((chunks[i].x - gncx)*(chunks[i].x - gncx) + (chunks[i].y - gncy)*(chunks[i].x - gncx))
			if(len < dist) then
			start
				near = chunks[i]
				dist = len
			end
		end
		return near
	end
	
	type Planet
	start
		radius = 16
		mass = 804.247719318987069
		
		x = 0
		y = 0
		velocity = 200
		facing = 0 
		
		r = 0 
		g = 0
		b = 0
		
		computer = 0
		
		tx = 0
		ty = 0
	end 
	
	Planet planets[8192]
	var planetc = 0
	
	function createPlanet()
	start
		planets[planetc].x = getRandomX()
		planets[planetc].y = getRandomY()
		planets[planetc].r = random()
		planets[planetc].g = random()
		planets[planetc].b = random()
		planets[planetc].facing = 0
		planetc = planetc + 1
	end
	
	function drawPlanet()
	start
		for(var i = 0 to planetc step 1)
		start
			Planet dpp
			dpp = planets[i]
			if(isVisible(dpp.x, dpp.y)) then
			start
				setColor(dpp.r, dpp.g, dpp.b, 0.392156862745098)
				drawEllipse(dpp.x, dpp.y, dpp.radius, dpp.radius, 0)
				setColor(dpp.r, dpp.g, dpp.b, 1)
				drawEllipse(dpp.x, dpp.y, dpp.radius, dpp.radius, 0)+
			end
		end 
	end 
	
	function getNearestPlanet(gnpx, gnpy)
	start
		Planet near
		var dist = 2147483648
		for(var i = 0 to planetc step 1)
		start
			var len = sqrt((planets[i].x - gnpx)*(planets[i].x - gnpx) + (planets[i].y - gnpy)*(planets[i].x - gnpx))
			if(len < dist) then
			start
				near = planets[i]
				dist = len
			end
		end
		return near
	end
	
	function destroyPlanet(dpplan)
	start
		if(dpplan <= planetc) then
			planets[ddplan].x = planets[planetc].x
			planets[ddplan].y = planets[planetc].y
			planets[ddplan].r = planets[planetc].r
			planets[ddplan].g = planets[planetc].g
			planets[ddplan].b = planets[planetc].b
			planets[dpplan].mass = planets[planetc].mass
			planets[dpplan].radius = planets[planetc].radius 
			planetc = planetc - 1
		end
	end 
	
	function isPlanetConsumable(planetA, planetB)
	start
		return 0.8*planetA.mass >= planetB.mass 
	end
	
	var FLEE_FOOD_PRIO = 0.2
	var FLEE_PRIO = 0.8
	
	var ATTACK_FOOD_PRIO = 0.4
	var ATTACK_PRIO = 0.6
	
	function updatePlanet(upfps)
	start
		for(var i = 0 to planetc step 1)
		start
			Planet dpp
			dpp = planets[i]
			
			if(dpp.computer) then
			start
				Planet pn
				Chunk cn
				pn = getNearestPlanet(dpp.x, dpp.y)
				cn = getNearestChunk(dpp.x, dpp.y)
				var prevx = dpp.x 
				var prevy = dpp.y
				var ang = dpp.facing
				var fprio = 1.0
				if(isPlanetConsumable(dpp, pn)) then
				start
					if((dpp.x - pn.x)*(dpp.x - pn.x) + (dpp.y - pn.y)*(dpp.y - pn.y) < dpp.radius*dpp.radius) then
					start
						dpp.mass = dpp.mass + pn.mass
						dpp.radius = getRadius(dpp.mass)
						destroyPlanet(i)
					end
					else
					start
						ang = atan2(pn.y - dpp.y, pn.x - dpp.x)
						dpp.x = dpp.x + dpp.velocity*upfps*cos(ang)*ATTACK_PRIO
						dpp.y = dpp.y + dpp.velocity*upfps*sin(ang)*ATTACK_PRIO
						fprio = ATTACK_FOOD_PRIO
					end
				end
				else if(isPlanetConsumable(pn, dpp)) then
					ang = atan2(dpp.y - pn.y, dpp.x - pn.x)
					dpp.x = dpp.x + dpp.velocity*upfps*cos(ang)*FLEE_PRIO
					dpp.y = dpp.y + dpp.velocity*upfps*sin(ang)*FLEE_PRIO
					fprio = FLEE_PRIO
				end 
				if((dpp.x - pn.x)*(dpp.x - pn.x) + (dpp.y - pn.y)*(dpp.y - pn.y) < dpp.radius*dpp.radius) then
				start
				
				end
				else
				start
					ang = atan2(cn.y - dpp.y, cn.x - dpp.x)
					dpp.x = dpp.x + dpp.velocity*upfps*cos(ang)*fprio
					dpp.y = dpp.y + dpp.velocity*upfps*sin(ang)*fprio
					dpp.facing = atan2(dpp.y - prevy, dpp.x - prevx)
				end
			end
			else
				if((tx - dpp.x)*(tx - dpp.x) + (ty - dpp.y)*(ty - dpp.y) > 0) then
				start
					dpp.x = dpp.x + dpp.velocity*upfps*cos(dpp.facing)
					dpp.y = dpp.y + dpp.velocity*upfps*cos(dpp.facing)
				end
			end
		end
	end
end
